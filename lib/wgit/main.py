#!/usr/bin/python3
import os
import sys
import shutil
import zlib
import re
import asyncio
import requests
import argparse

DESCRIPTION = "WGIT : WGET utility, but for downloading git repository exposed over the internet"

def parse_args():
    parser = argparse.ArgumentParser(description=DESCRIPTION, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("url", help="Git repository url")
    parser.add_argument("--dest", help="Folder to save in, please note it will save files in `<dest>/.git`", default="wgit.out")
    return dict(vars(parser.parse_args()))

def flatten_array(arr):
    flattened = []
    for inner_arr in arr:
        for item in inner_arr:
            flattened.append(item)
    return flattened

def git_parse_tree(data):
    entries = []
    offset = 0

    while offset < len(data):
        space_index = data.find(32, offset)  
        null_index = data.find(0, space_index + 1) 
        mode = data[offset:space_index].decode()
        name = data[space_index + 1:null_index].decode()
        hash = data[null_index + 1:null_index + 21].hex()

        entries.append({'mode': mode, 'name': name, 'hash': hash})
        offset = null_index + 21

    return entries

def git_cat_file(object_path):
    with open(object_path, 'rb') as f:
        data = f.read()

        try:
            decompressed_data = zlib.decompress(data)
            header = decompressed_data[:4].decode()
            if header == 'tree':
                parsed_tree = git_parse_tree(decompressed_data[5:])
                output = '\n'.join(f"{entry['mode']} {entry['name']} {entry['hash']}" for entry in parsed_tree)
                return output
            else:
                return decompressed_data[:].decode()
        except Exception:
            return ''

def extract_objects(content):
    pattern = r'([a-fA-F0-9]{2})([a-fA-F0-9]{38})'
    matches = re.findall(pattern, content)
    return [f"/objects/{match[0]}/{match[1]}" for match in matches]

def list_files_recursively(dir_path):
    result = []
    for root, _, files in os.walk(dir_path):
        for file in files:
            file_path = os.path.join(root, file)
            result.append(file_path)
    return result

def download_file(url, local_path):
    print(f"Downloading file : {url}")
    response = requests.get(url, stream=True)
    with open(local_path, 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)

async def run(url, dest):
    dest = dest.rstrip('/') + "/.git"
    shutil.rmtree(dest, ignore_errors=True)
    os.makedirs(dest)

    downloaded_paths = set()
    def dl(path):
        if path in downloaded_paths:
            return
        directory = os.path.dirname(os.path.join(dest, path.lstrip('/')))
        if not os.path.exists(directory):
            os.makedirs(directory)
        download_file(url.rstrip("/") + "/" + path.lstrip("/"), os.path.join(dest, path.lstrip('/')))
        downloaded_paths.add(path)

    dl("/index")
    dl("/description")
    dl("/config")
    dl("/HEAD")
    dl("/COMMIT_EDITMSG")
    dl("/logs/HEAD")
    refs = []
    with open(os.path.join(dest, "HEAD"), "r", encoding="utf-8") as f:
        refs = [line.split(":")[1].strip() for line in f if line.split(":")[1].strip()]
    for ref in refs:
        dl(ref)
        dl("/logs/" + ref)

    for ref in refs:
        with open(os.path.join(dest, ("logs/" + ref)), "r", encoding="utf-8") as f:
            content = f.read()
            objects = extract_objects(content)
            for obj in objects:
                dl(obj)

    downloaded_objects = set()
 
    def dl_object_recursive():
        r = list_files_recursively(os.path.join(dest, "objects"))
        to_download = [extract_objects(git_cat_file(file)) for file in r]
        objects_to_download = [obj for obj in flatten_array(to_download) if obj and obj not in downloaded_objects]

        if not objects_to_download:
            return

        for obj in objects_to_download:
            dl(obj)

        downloaded_objects.update(objects_to_download)
        dl_object_recursive()

    dl_object_recursive()

if __name__ == "__main__":
    args = parse_args()
    asyncio.run(run(**args))
